# 数据库备份、恢复、迁移

## 1.日志管理

### 1.1  general_log

作用：

> 一般不会开启开功能，因为log的量会非常庞大。但个别情况下可能会临时的开一会儿general log以供调试使用。

查询：

> show variables like 'general_log'; -- 查看日志是否开启
>
> show variables like 'general_log_file'; -- 看看日志文件保存位置
>
> show variables like 'log_output'; -- 看看日志输出类型 table或file
>
> set global general_log=on; -- 开启日志功能
>
> set global general_log_file='/data/logs/general.log'; -- 设置日志文件保存位置
>
> set global log_output='table'; -- 设置输出类型为 table
>
> set global log_output='file'; -- 设置输出类型为 file
>
> set global log_output='table,file'; -- 设置多位置保存

### 1.2 binlog

配置：

> 注意：MySQL默认是没有开启二进制日志的。
>
> 基础参数查看:
>
> 开关:
>
> [(none)]>select @@log_bin;
>
> 日志路径及名字
>
> [(none)]>select @@log_bin_basename;
>
> 服务ID号:
>
> [(none)]>select @@server_id;
>
> 二进制日志格式:
>
> [(none)]>select @@binlog_format;

binlog记录的内容：

二进制日志（binlog）是MySQL的**逻辑日志**，它记录了对数据库**内容**进行更改的所有**事件（Events）**（不包括`SELECT`、`SHOW`等查询操作）。它的核心目的是用于**复制**和**数据恢复**。

### 1.3 gtid特性

5.6 版本新加的特性,5.7中做了加强

5.6 中不开启,没有这个功能.

5.7+ 中的GTID,即使不开也会有自动生成

SET @@SESSION.GTID_NEXT= 'ANONYMOUS'

是对于一个已提交事务的编号，并且是一个全局唯一的编号。

它的官方定义如下：

GTID = server_uuid ：transaction_id

7E11FA47-31CA-19E1-9E56-C43AA21293967:1-1000

重要参数介绍：

vim /etc/my.cnf

gtid-mode=on

enforce-gtid-consistency=true

log-slave-updates=1

systemctl restart mysqld

| 对比点     | pos 复制（binlog+position）                 | GTID 复制（全局事务 ID）                             |
| ---------- | ------------------------------------------- | ---------------------------------------------------- |
| 标识方式   | `binlog 文件名 + pos`（偏移量）             | `UUID:事务编号`（全局唯一 ID）                       |
| 配置复杂度 | 高，需要手动指定文件和位置                  | 低，从库自动对齐缺失的事务                           |
| 主从切换   | 麻烦，需要人工找对 pos                      | 简单，直接依赖 GTID 集合                             |
| 容错性     | 容易错位或遗漏，出错难排查                  | 基本不会错，自动跳过已执行事务                       |
| 使用工具   | `mysqlbinlog --start-position=xxx` 截取日志 | `mysqlbinlog --include-gtids=xxx` 直接按事务 ID 截取 |
| 典型应用   | 老版本 MySQL (<5.6) 或没启用 GTID 的场景    | 新版本推荐（MySQL 5.6+ 支持 GTID）                   |

问题：MySQL **binlog 写入 page cache（页缓存）还没刷到磁盘**的时候，数据库突然宕机。这种场景在数据恢复里算是 **非持久化日志丢失** 的典型例子。分析如下：

------

#### 1. 发生了什么

- MySQL 写 binlog 时先写 **操作系统 page cache**（内存中的缓冲区），并非直接刷盘。
- 如果宕机发生在 flush 前，binlog 里就**少了一部分事务**。
- 事务可能已经提交到 InnoDB redo log，但 binlog 没刷盘，这就是 **binlog 与数据库数据不一致** 的情况。

------

#### 2. 影响

- **从库**：如果是主从复制场景，缺少的 binlog 事务从库拉不到，会导致 **主从数据不一致**。
- **数据恢复**：依赖 binlog 回放的方式会缺少这些事务。

------

#### 3. 恢复思路

#### 方法 A：基于 InnoDB redo log

- 如果事务已经提交到 InnoDB redo log 或者已经写入了数据页，但 binlog 没写入磁盘：
  - 重启数据库，InnoDB 会做 crash recovery，redo log 会保证 **数据页回滚到事务提交点**。
  - 然而 **binlog 里不会有这些事务**，从库无法自动同步这部分。

#### 方法 B：手工恢复丢失 binlog 数据

1. **分析主库数据**
   - 找出最后一次从库同步成功的 GTID 或 binlog pos。
   - 用 SQL 对比主从差异，找出主库上多出的事务。
2. **手工生成补丁**
   - 导出差异 SQL，或者用工具（pt-table-sync, gh-ost diff 等）同步从库。
   - 在 GTID 模式下，缺失的事务可以通过手工执行 `SET GTID_NEXT='xxxx:nnn'; BEGIN; … COMMIT;` 方式补回。

#### 方法 C：未来避免策略

- 开启 **sync_binlog=1**
  - 让 MySQL 每提交一个事务就把 binlog 刷盘，保证 binlog 与事务同步，防止 page cache 丢失。
- 对主库和关键事务开启 **innodb_flush_log_at_trx_commit=1**
  - Redo log 每提交都刷盘，保证 crash recovery 与 binlog 一致。

------

总结：

- 丢失 binlog 的事务，如果在 InnoDB redo log 里已经提交，可以恢复主库数据，但 binlog 仍然缺失。
- 从库需要 **人工对比主库差异** 或 **手工补 GTID** 来恢复同步。
- 根本解决办法是开启 `sync_binlog=1`，防止 page cache 未刷盘丢失事务。